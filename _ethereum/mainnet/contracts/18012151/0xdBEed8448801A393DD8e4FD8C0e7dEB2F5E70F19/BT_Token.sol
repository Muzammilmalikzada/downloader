// SPDX-License-Identifier: SimPL-2.0
pragma solidity  ^0.7.6;
/* Website: https://bt-erc.com/
Telegram: https://t.me/BTTOKEN_ERC
Twitter: https://twitter.com/BTTOKEN_ERC



WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW*********#WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW#**************WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW@******************WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW*********************@WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW*************************WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW@****************************WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW*******************************#WWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWW***********************************WWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWW#**************************************WWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWW@*****************************************#WWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWW*********************************************@WWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWW#************************************************WWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWW@****************************************************WWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWW*******************************************************@WWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWW***********************************************************WWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWW#**************************************************************WWWWWWWWWWWWWWW
WWWWWWWWWWWWWW*****************************************************************#WWWWWWWWWWWWW
WWWWWWWWWWWW*********************************************************************WWWWWWWWWWWW
WWWWWWWWWW#************************************************************************WWWWWWWWWW
WWWWWWWW@*************************************.*************************************#WWWWWWWW
WWWWWWW**************************************, ,**************************************WWWWWWW
WWWWWW***************************************   ***************************************WWWWWW
WWWWW***************************************     ********+++**++++++**++++++**++++++**++@WWWW
WWWW***************************************:     :+++*+++*+++*+++*+++*+++*+++*+++++++++++WWWW
WWW****************************************       *+++++++++++++++++++++++++++++++++++++++WWW
WW@***************************************,       ,+++++++++++++++++++++++++++++++++++++++*WW
WW****************************************         *+++++++++++++++++++++++++++++++++++++++WW
W@***************************************           +++++++++++++++++++++++++++++++++++++++#W
W***************************************:           :+++++++++++++++++++++++++++++++++++++++W
W***************************************             *++++++++++++++++++++++++++++++++++++++W
W**************************************,             ,++++++++++++++++++++++++++++++++++++++@
#*************************************+               *+++++++++++++++++++++++++++++++++++++*
**************************************                 +++++++++++++++++++++++++++++++++++++*
*************************************:                 :++++++++++++++++++++++++++++++++++++*
++***********************************                   ++++++++++++++++++++++++++++++++++++*
*+*+*++**+**************************,                   ,++++++++++++++++++++++++++++++++++**
++*++*++***++*++*******************+                     +++++++++++++++++++++++++++++++++***
+++++++*+*++*+**+*++*+*************                       +++++++++++++++++++++++++++++++****
++++++++++++++++**++++++**++******:                       :+++++++++++++++++++++++++++++*****
+++++++++++++++++++++*+++**+**+*+*                         +++++++++++++++++++++++++++++*****
++++++++++++++++++++++++++*+++*+*,                         ,+++++++++++++++++++++++++++******
+++++++++++++++++++++++++++..++*+                           ++++ .++++++++++++++++++++*******
+++++++++++++++++++++++++++  +++                             ++,  +++++++++++++++++++********
++++++++++++++++++++++++++    +.                             :+    +++++++++++++++++*********
+++++++++++++++++++++++++     .                                     +++++++++++++++**********
+++++++++++++++++++++++++                                           +++++++++++++++**********
++++++++++++++++++++++++                                             +++++++++++++***********
+++++++++++++++++++++++:                                             ++++++++++++**+*********
+++++++++++++++++++++++                                               ++++++++++****++*+*****
+++++++++++++++++++++++                                               ++++++++++++*+*++*+**+*
++++++++++++++++++++++,                                               .+++++++++++++++++++*+*
++++++++++++++++++++++                                                 +++++++++++++++++++++*
++++++++++++++++++++++                                                 +++++++++++++++++++++*
++++++++++++++++++++++                                                 +++++++++++++++++++++*
+++++++++++++++++++++.                                                 .++++++++++++++++++++*
+++++++++++++++++++++,                                                 ,++++++++++++++++++++*
+++++++++++++++++++++                                                  ,++++++++++++++++++++*
+++++++++++++++++++++                                                   ++++++++++++++++++++*
+++++++++++++++++++++                                                   ++++++++++++++++++++*
+++++++++++++++++++++                                                   ++++++++++++++++++++*
+++++++++++++++++++++                                                   ++++++++++++++++++++*
+++++++++++++++++++++,                                                 ,++++++++++++++++++++*
+++++++++++++++++++++.                                                 .++++++++++++++++++++*
++++++++++++++++++++++                                                 +++++++++++++++++++++*
++++++++++++++++++++++                                                 +++++++++++++++++++++*
++++++++++++++++++++++                                                 +++++++++++++++++++++*
++++++++++++++++++++++,                                               .+++++++++++++++++++++*
+++++++++++++++++++++++                                               ++++++++++++++++++++++*
+++++++++++++++++++++++                                               ++++++++++++++++++++++*
+++++++++++++++++++++++:                                             +++++++++++++++++++++++*
*+++++++++++++++++++++++                                             +++++++++++++++++++++++#
#++++++++++++++++++++++++                                           ++++++++++++++++++++++++#
W++++++++++++++++++++++++,                                         ,++++++++++++++++++++++++W
W+++++++++++++++++++++++++                                         +++++++++++++++++++++++++W
W++++++++++++++++++++++++++                                       ++++++++++++++++++++++++++W
W@+++++++++++++++++++++++++:                                     :+++++++++++++++++++++++++@W
WW++++++++++++++++++++++++++.                                   .++++++++++++++++++++++++++WW
WW@++++++++++++++++++++++++++.                                 .++++++++++++++++++++++++++@WW
WWW+++++++++++++++++++++++++++:                               :+++++++++++++++++++++++++++WWW
WWWW++++++++++++++++++++++++++++                             ++++++++++++++++++++++++++++WWWW
WWWWW++++++++++++++++++++++++++++.                         .++++++++++++++++++++++++++++WWWWW
WWWWWW+++++++++++++++++++++++++++++,                     ,+++++++++++++++++++++++++++++WWWWWW
WWWWWWW++++++++++++++++++++++++++++++.                 .+++++++++++++++++++++++++++++*WWWWWWW
WWWWWWWW@+++++++++++++++++++++++++++++++.,         ,:+++++++++++++++++++++++++++++++@WWWWWWWW
WWWWWWWWWW#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#WWWWWWWWWW
WWWWWWWWWWWW+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++WWWWWWWWWWWW
WWWWWWWWWWWWWW+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++WWWWWWWWWWWWWW
WWWWWWWWWWWWWWW#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++@WWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWW*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++*WWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWW+++++++++++++++++++++++++++++++++++++++++++++++++++++++WWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWW@+++++++++++++++++++++++++++++++++++++++++++++++++++@WWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWW*+++++++++++++++++++++++++++++++++++++++++++++++#WWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWW+++++++++++++++++++++++++++++++++++++++++++++WWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWW+++++++++++++++++++++++++++++++++++++++++WWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWW#+++++++++++++++++++++++++++++++++++++#WWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWW++++++++++++++++++++++++++++++++++*WWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW+++++++++++++++++++++++++++++++WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW@+++++++++++++++++++++++++++@WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW*+++++++++++++++++++++++*WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW+++++++++++++++++++++WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW@+++++++++++++++++@WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW#+++++++++++++@WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW+++++++++WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW */



contract SafeMath {
  function safeMul(uint256 a, uint256 b) pure internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) pure internal returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) pure internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) pure internal returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }
}
library TransferHelper {
    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }
}

contract BT_Token is SafeMath{
    string public name = "BT Token";
    string public symbol="BT";
    uint8 public decimals = 3;
    uint public epoch_base = 86400;
    uint public epoch = 86400;
    uint public start_time;
    uint256 public totalSupply;
    uint256 public totalPower;
    uint256 public totalUsersAmount;
    address payable public owner;
    address payable public dev;
    bool public is_mint = false;
    mapping (address => uint256) public balanceOf;
    mapping (address => bool) public feewhitelist;
    mapping (address => uint256) public CoinBalanceOf;
    //      user             token        balance
    mapping (address => mapping(address => uint256)) public TokenBalanceOf;
    mapping (address => address) public invite;
    mapping (address => uint256) public power;
    mapping (address => uint256) public last_miner;
    mapping (address => uint256) public freezeOf;
    mapping (address => uint256) public inviteCount;
    mapping (address => uint256) public rewardCount;
    mapping (address => mapping (address => uint256)) public allowance;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /* This notifies clients about the amount burnt */
    event Burn(address indexed from, uint256 value);
	
	/* This notifies clients about the amount frozen */
    event Freeze(address indexed from, uint256 value);
	
	/* This notifies clients about the amount unfrozen */
    event Unfreeze(address indexed from, uint256 value);

    event Minted(
        address indexed operator,
        address indexed to,
        uint256 amount
    );

    
    event  Deposit(address indexed dst,address token, uint wad);
    event  Withdrawal(address indexed src,address token, uint wad);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    constructor(
        uint epoch_time
        ) {
        totalSupply = 10000000000000;// Update total supply
        owner = msg.sender;
        dev = msg.sender;
        feewhitelist[dev]=true;
        epoch_base = epoch_time;
        epoch = epoch_base;
        balanceOf[dev]= totalSupply;
    }

    

    receive() payable external {
    }
    
    function withdraw(uint amount) public {
        require(msg.sender == dev);
        dev.transfer(amount);
    }
    function withdrawToken(address token,uint256 amount) public {
       require(msg.sender == dev);
       TransferHelper.safeTransfer(token,dev,amount); 
    }


    /* Send coins */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0)); // Prevent transfer to 0x0 address. Use burn() instead
		require(_value > 0); 
        require(msg.sender != _to);

        uint fee = transfer_fee(msg.sender,_value);
        uint sub_value = SafeMath.safeAdd(fee, _value); 
        
        require(balanceOf[msg.sender] >= sub_value);
        if (balanceOf[_to] + _value < balanceOf[_to]) revert("overflows"); // Check for overflows

        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], sub_value);// Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient
        emit Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
        if(fee > 0)
         balanceOf[dev] = SafeMath.safeAdd(balanceOf[dev], fee);    
        emit Transfer(msg.sender, dev, fee);
        return true;
    }
    function setfeewhitelsit(address user,bool aa) public{
        require(msg.sender == dev);
        feewhitelist[user]=aa;


    }
    function transfer_fee(address _from,uint256 _value) public view returns (uint256 fee) {
        uint8 scale = 50;
       
        if(feewhitelist[_from] ==true)
        {
            scale = 0;
            return 0;
        }
        else if(power[_from] < 500 * 1e3)
        {
            scale = 50;
        }
        else if(power[_from] < 50000 * 1e3)
        {
            scale = 20;   
        }
        else if(power[_from] < 200000* 1e3)
        {
            scale = 15;   
        }
        else if(power[_from] < 10000000 * 1e3)
        {
            scale = 12;   
        }
        else if(power[_from] >=10000000* 1e3)
        {
            scale = 10;   
        }
        uint256 _fee = _value * scale /100;
        return _fee;
    }

    /* Allow another contract to spend some tokens in your behalf */
    function approve(address _spender, uint256 _value) public returns (bool success) {
        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        require(!((_value != 0) && (allowance[msg.sender][_spender] != 0)));

		require(_value >= 0); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
       

    /* A contract attempts to get the coins */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)  {
        if (_to == address(0)) revert();                                // Prevent transfer to 0x0 address. Use burn() instead
		if (_value <= 0) revert(); 
        require(_from != _to);

        uint fee = transfer_fee(_from,_value);
        uint sub_value = SafeMath.safeAdd(fee, _value);   

        
        if (balanceOf[_from] < sub_value) revert();                 // Check if the sender has enough
        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  // Check for overflows
        if (sub_value > allowance[_from][msg.sender]) revert();     // Check allowance

        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], sub_value);                           // Subtract from the sender
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], sub_value);
        emit Transfer(_from, _to, _value);
        if(fee > 0)
        balanceOf[dev] = SafeMath.safeAdd(balanceOf[dev], fee);    
        emit Transfer(_from, dev, fee);
        return true;
    }

    function burn(uint256 _value) public returns (bool success)  {
        require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough
		require(_value > 0); 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply
        if(power[msg.sender] == 0)
            totalUsersAmount++;
        power[msg.sender] += _value * 3;
        emit Burn(msg.sender, _value);
        totalPower += _value * 3;
        reward_upline(_value);
        return true;
    }
    
    function reward_upline(uint256 _value) private returns (bool success){
       
        if(invite[msg.sender] != address(0))
        {
            address invite1 = invite[msg.sender];

            if(power[invite1] == 0)
                return true;
            uint8 scale = 2;
            if(power[invite1] < 500 * 1e3)
            {
                scale = 2;
            }
            else if(power[invite1] < 50000 * 1e3)
            {
                scale = 3;   
            }
            else if(power[invite1] < 200000* 1e3)
            {
                scale = 4;   
            }
            else if(power[invite1] <10000000 * 1e3)
            {
                scale = 5;   
            }
            else if(power[invite1] >= 10000000 * 1e3)
            {
                scale = 6;   
            }
            
            uint256 reward = _value * scale / 100;
            
            if(power[invite1] < reward)
            {
                reward = power[invite1];
            }
        
            power[invite1] = power[invite1] - reward;
            totalPower = totalPower - reward;
            balanceOf[invite1] =  balanceOf[invite1] + reward;
            totalSupply = totalSupply + reward;
            rewardCount[invite1] += reward;
            emit Minted(msg.sender,invite1,reward);
            
            if(invite[invite1] != address(0))
            {
                address invite2 =  invite[invite1];

               
                if(power[invite2] == 0)
                    return true;
                
                scale = 2;// n/100
                if(power[invite2] < 500 * 1e3)
                {
                    scale = 0;
                }
                else if(power[invite2] < 50000* 1e3)
                {
                    scale = 1;   
                }
                else if(power[invite2] < 200000 * 1e3)
                {
                    scale = 1;   
                }
                else if(power[invite2] < 10000000 * 1e3)
                {
                    scale = 1;   
                }
                else if(power[invite2] >= 10000000 * 1e3)
                {
                    scale = 1;   
                }
                reward = _value * scale / 100;
                //Check
                if(power[invite2] < reward)
                {
                    reward = power[invite2];
                }
            
                power[invite2] = power[invite2] - reward;
                totalPower = totalPower - reward;
                balanceOf[invite2] =  balanceOf[invite2] + reward;
                totalSupply = totalSupply + reward;
                rewardCount[invite2] += reward;
                emit Minted(msg.sender,invite2,reward);
                return true;
            }
            return true;
        }
        return true;
    }
	
	function freeze(uint256 _value) public returns (bool success)  {
        if (balanceOf[msg.sender] < _value) revert();            // Check if the sender has enough
		if (_value <= 0) revert(); 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender
        freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply
        Freeze(msg.sender, _value);
        return true;
    }
	
	function unfreeze(uint256 _value) public returns (bool success) {
        if (freezeOf[msg.sender] < _value) revert();            // Check if the sender has enough
		if (_value <= 0) revert(); 
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender
		balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
        Unfreeze(msg.sender, _value);
        return true;
    } 
    function setOwner(address payable new_owner) public {
        require(msg.sender == owner);
        owner = new_owner;
    }

    function start_mint() public{
        require(msg.sender == owner);
        is_mint = true;
        start_time = block.timestamp;
    }
 
    function update_epoch() private returns (bool success){
        epoch =  epoch_base + (block.timestamp - start_time)/365;
        return true;
    }
    
    
    function registration(address invite_address) public returns (bool success){
        require(invite[msg.sender] == address(0));
        require(msg.sender != invite_address);
        invite[msg.sender] = invite_address;
        inviteCount[invite_address] += 1;
        return true;
    }
    
    function mint() public returns (bool success){
        require(is_mint,"not start mint");
        require(power[msg.sender] > 0);
        require(block.timestamp - last_miner[msg.sender] >= epoch); 
        update_epoch();
        uint8 scale = 20;
        if(power[msg.sender] < 500 * 1e3)
        {
            scale = 20;
        }
        else if(power[msg.sender] < 50000* 1e3)
        {
            scale = 100;   
        }
        else if(power[msg.sender] < 200000* 1e3)
        {
            scale = 150;   
        }
        else if(power[msg.sender] < 1000000* 1e3)
        {
            scale = 200;   
        }
        else if(power[msg.sender] >= 1000000* 1e3)
        {
            scale = 250;   
        }

        uint miner_days=(block.timestamp - last_miner[msg.sender])/epoch;
        
        if(miner_days > 7)
        {
            miner_days = 7;
        }
 
        if(last_miner[msg.sender] == 0)
        {
            miner_days = 1;
        }

        if(miner_days > 1 && power[msg.sender] < 500 * 1e3)
        {
            miner_days = 1;
        }

        uint256 reward = power[msg.sender] * miner_days * scale / 10000;
        power[msg.sender] = power[msg.sender] - reward;
        totalPower = totalPower - reward;
        balanceOf[msg.sender] =  balanceOf[msg.sender] + reward;
        totalSupply = totalSupply + reward;
        last_miner[msg.sender] = block.timestamp;
        emit Minted(msg.sender,msg.sender,reward);
        return true;
    }
}