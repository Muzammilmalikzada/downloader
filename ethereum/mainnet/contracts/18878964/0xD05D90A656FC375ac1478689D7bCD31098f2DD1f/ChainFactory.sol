/*
   ________          _       ______           __                  
  / ____/ /_  ____ _(_)___  / ____/___ ______/ /_____  _______  __
 / /   / __ \/ __ `/ / __ \/ /_  / __ `/ ___/ __/ __ \/ ___/ / / /
/ /___/ / / / /_/ / / / / / __/ / /_/ / /__/ /_/ /_/ / /  / /_/ / 
\____/_/ /_/\__,_/_/_/ /_/_/    \__,_/\___/\__/\____/_/   \__, /  
                                                         /____/   
  Smart-Contract generated and deployed by ChainFactory

  Web:      https://chainfactory.app/
  X:        https://x.com/ChainFactoryApp
  Telegram: https://t.me/ChainFactory
  Discord:  https://discord.gg/fpjxD39v3k
  YouTube:  https://youtube.com/@UpfrontDeFi

  By using this Smart-Contract generated and deployed by ChainFactory,
  you acknowledge and agree that ChainFactory shall not be liable for any
  damages arising from the use of this Smart-Contract, including but not
  limited to any damages resulting from any malicious or illegal use of
  the Smart-Contract by any third party or by the owner.

  The owner of the Smart-Contract generated by ChainFactory agrees not to
  misuse the Smart-Contract, including but not limited to:

  - Using the Smart-Contract to engage in any illegal or fraudulent
    activity, including but not limited to scams, theft, or money
    laundering.

  - Using the Smart-Contract in any manner that could cause harm to
    others, including but not limited to disrupting financial
    markets or causing financial loss to others.

  - Using the Smart-Contract to infringe upon the intellectual
    property rights of others, including but not limited to
    copyright, trademark, or patent infringement.

  The owner of the Smart-Contract generated by ChainFactory acknowledges
  that any misuse of the Smart-Contract may result in legal action,
  and agrees to indemnify and hold harmless ChainFactory from any and all
  claims, damages, or expenses arising from any such misuse.

*/

// SPDX-License-Identifier: MIT

pragma solidity 0.8.23;

import "./CF_Ownable.sol";
import "./CF_Common.sol";
import "./CF_ERC20.sol";
import "./CF_Recoverable.sol";
import "./CF_Burnable.sol";
import "./CF_Blacklist.sol";
import "./CF_Whitelist.sol";
import "./CF_Cooldown.sol";
import "./CF_MaxBalance.sol";
import "./CF_Taxable.sol";
import "./CF_DEXRouterV2.sol";

contract ChainFactory is CF_Ownable, CF_Common, CF_ERC20, CF_Recoverable, CF_Burnable, CF_Blacklist, CF_Whitelist, CF_Cooldown, CF_MaxBalance, CF_Taxable, CF_DEXRouterV2 {
  constructor() {
    _name = unicode"ChainFactory";
    _symbol = unicode"FACTORY";
    _decimals = 18;
    _totalSupply = 75000000000000000000000000; // 75,000,000 FACTORY
    _transferOwnership(0xb8F8a463a725502B5E0642bB0dc55CA8d1675434);
    _transferInitialSupply(0xb8F8a463a725502B5E0642bB0dc55CA8d1675434, 100000); // 100%
    _setEarlyPenaltyTime(120); // 2min
    _setDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 0xb8F8a463a725502B5E0642bB0dc55CA8d1675434);
    _setReflection(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    _setMinSwapPercent(500); // 0.5% of totalSupply
    _setMinTaxDistributionPercent(500); // 0.5% of totalSupply
    _setTaxBeneficiary(0, 0x6Aa1f46Fd34dDAa9f5EFcaB3Ebd43c54a87Cbf8E, [ uint24(0), uint24(5000), uint24(5000) ], [ uint24(40000), uint24(40000), uint24(40000) ]);
    _initialWhitelist([ 0xb8F8a463a725502B5E0642bB0dc55CA8d1675434 ]);
    _setCooldown(5, 3600, 3600); // 5 tx in 1h will result in a 1h freeze
    _setMaxBalancePercent(2000); // 2% of totalSupply
    _domainSeparator = keccak256(abi.encode(keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"), keccak256(bytes(_name)), keccak256(bytes("1")), block.chainid, address(this)));
    _initialized = true;
  }

  function _transfer(address from, address to, uint256 amount) internal virtual override {
    require(!_blacklisted[from] && !_blacklisted[to], "Blacklisted");
    require(to != address(0xdEaD));

    if (!_distributing && !_swapping && (from != _dex.pair && from != _dex.router)) {
      _autoSwap(false);
      _autoTaxDistribute(false);
    }

    if (amount > 0 && !_whitelisted[from] && !_whitelisted[to] && from != address(this) && to != address(this) && to != _dex.router) {
      require((from != _dex.pair && to != _dex.pair) || ((from == _dex.pair || to == _dex.pair) && _tradingEnabled > 0), "Trading disabled");

      unchecked {
        if (_cooldownPeriod > 0 && from != _dex.pair) {
          require(remainingCooldownTime(from) == 0, "Cooldown");

          if (_holder[from].start + _cooldownTriggerTime < _timestamp()) {
            _holder[from].count = 1;
            _holder[from].start = _timestamp();
          } else {
            if (++_holder[from].count >= _cooldownTriggerCount) { _cooldown(from); }
          }
        }

        require(_maxBalanceAmount == 0 || to == address(this) || (to == _dex.pair || to == _dex.router) || _balance[to] + amount <= _maxBalanceAmount, "Exceeds maxBalance");

        if (!_suspendTaxes && !_distributing && !_swapping) {
          uint256 appliedTax;
          uint8 taxType;

          if (from == _dex.pair || to == _dex.pair) { taxType = from == _dex.pair ? 1 : 2; }

          address _account = taxType == 1 ? to : from;

          if (_tradingEnabled + _earlyPenaltyTime >= _timestamp() && !_holder[_account].penalty) { _holder[_account].penalty = true; }

          for (uint8 i; i < 5; i++) {
            uint256 percent = uint256(taxType > 0 ? (taxType == 1 ? (_holder[_account].penalty ? _taxBeneficiary[i].penalty[1] : _taxBeneficiary[i].percent[1]) : (_holder[_account].penalty ? _taxBeneficiary[i].penalty[2] : _taxBeneficiary[i].percent[2])) : (_holder[_account].penalty ? _taxBeneficiary[i].penalty[0] : _taxBeneficiary[i].percent[0]));

            if (percent == 0) { continue; }

            uint256 taxAmount = _percentage(amount, percent);

            super._transfer(from, address(this), taxAmount);

            if (_taxBeneficiary[i].account == _dex.pair) {
              _amountForLiquidity += taxAmount;
            } else if (_taxBeneficiary[i].account == address(0xdEaD)) {
              _burn(address(this), taxAmount);
            } else {
              _taxBeneficiary[i].unclaimed += taxAmount;
              _amountForTaxDistribution += taxAmount;
            }

            appliedTax += taxAmount;
          }

          if (appliedTax > 0) {
            _totalTaxCollected += appliedTax;

            amount -= appliedTax;
          }
        }
      }
    }

    super._transfer(from, to, amount);
  }

  function _burn(address account, uint256 amount) internal virtual override {
    super._burn(account, amount);

    _setMaxBalancePercent(_maxBalancePercent);
    _setMinTaxDistributionPercent(_minTaxDistributionPercent);
    _setMinSwapPercent(_minSwapPercent);
  }

  function _transferInitialSupply(address account, uint24 percent) private {
    require(!_initialized);

    uint256 amount = _percentage(_totalSupply, uint256(percent));
    _balance[account] = amount;

    emit Transfer(address(0), account, amount);
  }

  /// @notice Returns a list specifying the renounce status of each feature
  function renounced() external view returns (bool Blacklist, bool Whitelist, bool Cooldown, bool MaxBalance, bool Taxable, bool DEXRouterV2) {
    return (_renounced.Blacklist, _renounced.Whitelist, _renounced.Cooldown, _renounced.MaxBalance, _renounced.Taxable, _renounced.DEXRouterV2);
  }

  /// @notice Returns basic information about this Smart-Contract
  function info() external view returns (string memory name, string memory symbol, uint8 decimals, address owner, uint256 totalSupply, string memory version) {
    return (_name, _symbol, _decimals, _owner, _totalSupply, _version);
  }

  receive() external payable { }
  fallback() external payable { }
}
